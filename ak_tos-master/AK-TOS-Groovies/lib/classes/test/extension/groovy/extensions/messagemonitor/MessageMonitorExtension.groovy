/*
 * Copyright (c) 2014 Navis LLC. All Rights Reserved.
 *
 */

package groovy.extensions.messagemonitor

import com.navis.apex.business.clusternotificationservice.*
import com.navis.argo.presentation.controller.CustomExternalAppController
import com.navis.external.argo.AbstractCustomMessageHandlerExtension
import com.navis.external.argo.ICustomMessageHandlerSendChannel
import com.navis.external.util.Message
import com.navis.framework.business.Roastery
import com.navis.framework.portal.UserContext
import org.jetbrains.annotations.NotNull
import org.jetbrains.annotations.Nullable

/**
 * This class implements the server side extension for the Message Monitor UI extension that displays a feed of the IChangeSubscriberService message
 * flow.
 */
class MessageMonitorExtension extends AbstractCustomMessageHandlerExtension implements IClusterNotificationSubscriber {

  @Override
  void initialize(@NotNull CustomExternalAppController inController) {
    _controller = inController;
    _sentClockSync = false;
    _propagationDelayMilliseconds = 0; // will be calculated after exchange of clock sync messages
    _clockOffsetMilliseconds = 0; // will be calculated after exchange of clock sync messages

    registerMessageHandler(CLOCK_SYNCHRONIZATION_MESSAGE_ID, new ClockSyncResponseHandler());

    _notificationFilter = new MessageMonitorSessionNotificationFilter();

    _notificationService = (IClusterNotificationService) Roastery.getBean(IClusterNotificationService.BEAN_ID);
    _notificationService.registerSubscriber(this);
  }

  @Override
  void close() {
    _notificationService.deregisterSubscriber(this);
  }

  private static String CHANGE_SUBSCRIBER_EVENT_ID = "ChangeSubscriberEvent";
  protected static String CLOCK_SYNCHRONIZATION_MESSAGE_ID = "ClockSyncEvent";

  @Override
  String getBriefDetails() {
    return "MessageMonitorExtension"; // todo: append session-specific identifying info
  }

  @Override
  Object getSubscriberTypeBroadcastFilter() {
    return new MessageMonitorBroadcastFilter();
  }

  @Override
  void initialize(@NotNull ICustomMessageHandlerSendChannel inSendChannel) {
  }

  @Override
  @NotNull
  IClusterNotificationFilter getFilter() {
    return _notificationFilter;
  }

  @Override
  void processNotification(@NotNull IClusterNotification inNotification) {
    if (!_sentClockSync) {
      Map<String, Object> params = new HashMap<String, Object>();
      params.put("t1", System.currentTimeMillis());
      Message m = Message.newRequest(CLOCK_SYNCHRONIZATION_MESSAGE_ID, params);

      _controller.pushMessage(m);
      _sentClockSync = true;
    }

    if (! (inNotification instanceof EntityChangeNotification)) {
      return;
    }

    EntityChangeNotification change = (EntityChangeNotification) inNotification;

    Map<String, Object> params = new HashMap<String, Object>();
    params.put("sourceName", change.getSourceName());
    params.put("originTimestamp", change.getOriginTimestamp());
    params.put("receiptTimestamp", System.currentTimeMillis());
    params.put("propagationDelay", _propagationDelayMilliseconds);
    params.put("clockOffset", _clockOffsetMilliseconds);
    params.put("changeType", change.getChangeType());
    params.put("entityType", change.getEntityType());
    params.put("updateValues", change.getValueHolders());
    Message m = Message.newRequest(CHANGE_SUBSCRIBER_EVENT_ID, params);

    _controller.pushMessage(m);
  }

  void setPropagationDelay(delayMilliseconds) {
    _propagationDelayMilliseconds = delayMilliseconds;
  }

  void setClockOffset(offsetMilliseconds) {
    _clockOffsetMilliseconds = offsetMilliseconds;
  }

  private IClusterNotificationFilter  _notificationFilter;
  private IClusterNotificationService _notificationService;
  private CustomExternalAppController _controller;
  private boolean                     _sentClockSync;
  private long                        _propagationDelayMilliseconds;
  private long                        _clockOffsetMilliseconds;
}

// TODO: This filter needs to be created at startup. Its constructor registers itself as a broadcast filter.

class MessageMonitorBroadcastFilter implements IClusterNotificationFilter {

  public MessageMonitorBroadcastFilter() {
  }

  @Override
  boolean acceptsNotification(@NotNull @NotNull IClusterNotification inNotification) {
    // This may seem counter-intuitive, but remember that the Message Monitor does not generate traffic; it just displays all traffic generated by
    // other broadcasters. Therefore, we return false here. It's because we do not want to ask for traffic at this broadcast filter point, rather
    // we only want whatever else is already being accepted by other extensions. If we returned true, it would defeat the purpose of broadcast-side
    // filtering, and would cause every notification to be broadcast no matter what.
    return false;
  }

  @Override
  String getBriefDetails() {
    return "MessageMonitorBroadcastFilter";
  }
}

class MessageMonitorSessionNotificationFilter implements IClusterNotificationFilter {

  @Override
  boolean acceptsNotification(@NotNull @NotNull IClusterNotification inNotification) {
    return true;
  }

  @Override
  String getBriefDetails() {
    return "MessageMonitorSessionNotificationFilter";
  }
}

class ClockSyncResponseHandler extends AbstractCustomMessageHandlerExtension.AbstractMessageHandler {

  @Override
  @NotNull
  AbstractCustomMessageHandlerExtension.AbstractMessageHandler factory(@NotNull AbstractCustomMessageHandlerExtension inParentMessageHandler, @NotNull Message inRequest) {
    return new ClockSyncResponseHandler(inParentMessageHandler, inRequest);
  }

  public ClockSyncResponseHandler() {
    super();
  }

  @Override
  AbstractCustomMessageHandlerExtension.AbstractMessageHandler factory(@NotNull AbstractCustomMessageHandlerExtension inParentMessageHandler,
                                                                       @NotNull UserContext inUserContext, @NotNull Message inRequest) {
    return null
  }

  public ClockSyncResponseHandler(@NotNull AbstractCustomMessageHandlerExtension inParentMessageHandler, @NotNull Message inRequest) {
    super(inParentMessageHandler, inRequest);
  }

  @Override
  @Nullable
  public Message handleMessage() {
    Long t4 = System.currentTimeMillis();
    Long t1 = (Long) _request.getParameters().get("t1");
    Long t2 = (Long) _request.getParameters().get("t2");
    Long t3 = (Long) _request.getParameters().get("t3");

    /*
    Propagation delay calculation:
      D = ((t2 - t1) + (t4 - t3)) / 2
    Offset calculation:
      O = ((t2 - t1) - (t4 - t3)) / 2
    */

    Long delayMilliseconds = ((t2 - t1) + (t4 - t3)) / 2;
    ((MessageMonitorExtension) _parentMessageHandler).setPropagationDelay(delayMilliseconds);
    Long offsetMilliseconds = ((t2 - t1) - (t4 - t3)) / 2;
    ((MessageMonitorExtension) _parentMessageHandler).setClockOffset(offsetMilliseconds);

    return null; // There is no response; we are handling a response, not returning one.
  }

  @Override
  protected void doInTransaction() {
    // n/a - Work occurs in handleMessage, with no transaction involved. Will not be called.
  }

}
